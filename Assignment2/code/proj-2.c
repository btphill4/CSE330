#include "sem.h"

int buffSize, produce, consu, numRepeat, ReadyQEmpty;
int buff_full = 0;	//1 is full 0 is not full
int ReadyQ[1000];
int Buffer[1000];
int Wait[1000];

void read_lines(){
	scanf("%d,%d,%d,%d", &buffSize, &produce, &consu, &numRepeat);
	
	if((buffSize > 0) && (produce >= 0) && (consu >= 0) && (numRepeat > 0)){
		int count = 0;	
		int temp = 0;
		int totalLeng = produce + consu;
		
		
		count = 0;
		while(count < buffSize){		//If buff[i] == 0 it is empty space
			Buffer[count] = 0;
			//printf("%d", Buffer[count]);
			count++;
		}
		
		count = 0;
		while(count < totalLeng){		//Initialize and save to ReadyQ
			scanf("%d", &temp);
			ReadyQ[count] = temp;
			//printf("%d\n", ReadyQ[count]);
			count++;
		}
		
		count = 0;
		//while(count < totalLeng){
		//	printf("%d\n", ReadyQ[count]); 
		//	count++;
		//}
		
		int inBufferSize = 0;
		int toWait = 0;
		int iteration = 1;
		int inWait = 0;
		int newTotal = totalLeng;
		int totalCount = 0;
		int first = ReadyQ[0];
		int firstDone = 0;
		for(int z = 0; z < numRepeat + 1; z++){
			for(int i = 0; i < totalLeng; i++){
			//while(ReadyQ[0] != 0){
				if((newTotal > 0) && (ReadyQ[0] != 0) ){
					if(ReadyQ[0] >= 1){		//RQ is producer
						if(first == ReadyQ[0]){
							if(firstDone  == 0){
								firstDone = 1;	
								//printf("Iteration %d\n", iteration);					
							} else {
								iteration++;
								//printf("Iteration Increment %d\n", iteration);
							}
						
						}
						if(inBufferSize == buffSize){	//Buffer full
							temp = 0;
							while(Wait[temp] != 0){
								//printf("%d", Wait[temp]);
								temp++;
							}
							inWait++;
							Wait[temp] = ReadyQ[0];
							//printf("Wait[0] %d", Wait[temp]);
							toWait = 1;
							
							printf("\n Producer %d is waiting \n", ReadyQ[0]);
							//End, remove RQ[0] and shift queue over 
							
						
						
						} else {	//Produce
							printf("\n Producer %d is producing item number %d \n", ReadyQ[0], iteration);
							count = 0;
							while(Buffer[count] != 0){
								count++;
							
							}
							Buffer[count] = ReadyQ[0];
							if (iteration != numRepeat) {	
								toWait = 0;
							} else {
								toWait = 1;
							}
							
							inBufferSize++;
						}
						
					
					} else if (ReadyQ[0] < 1) {			//RQ is consumer
						if(inBufferSize == 0){	//Buffer empty
							temp = 0;
							while(Wait[temp] != 0){
								//printf("%d", Wait[temp]);
								temp++;
							}
							
							inWait++;
							Wait[temp] = ReadyQ[0];
							//printf("Wait[0] %d", Wait[temp]);
							toWait = 1;
							
							printf("\n Consumer %d is waiting \n", (ReadyQ[0] * -1));
							//End, remove RQ[0] and shift queue over 
							
						
						
						} else {
							//Consume buffer[0] reduce wait
							printf("\n Consumer %d is consuming item generated by Producer %d \n", (ReadyQ[0] * -1), Buffer[0]);
							count = 0;
							while(count < buffSize){
								Buffer[count] = Buffer[count + 1];
								count++;
							}
							
							int waitVal = Wait[0];
							//printf("Wait val %d\n", waitVal);
							
							count = 0;
							while(count < inWait){
								Wait[count] = Wait[count + 1];
								count++;
							}					
							inWait--;
							count = 0;
							while(ReadyQ[count] != 0){
								count++;
								
							}
							ReadyQ[count] = waitVal;
							newTotal++;	
													
							if (iteration != numRepeat) {			
								toWait = 0;
							} else {
								toWait = 1;
							}
							inBufferSize--;				
						}
						
						
					
					}
					
					
					if(toWait == 1){
						//shift the ReadyQ over by one and remove RQ1
						count = 0;
						//int firstVal = ReadyQ[0]
						while(ReadyQ[count] != 0){
							ReadyQ[count] = ReadyQ[count + 1];
							
							count++;
						}
						newTotal--;
						//printf("New total %d \n", newTotal);	
						toWait = 0;
							
					} else {
					
						//Rotate the first val to last val, shift other elements up 1 position
						count = 0;
						int firstVal = ReadyQ[0];
						while(ReadyQ[count] != 0){
							ReadyQ[count] = ReadyQ[count + 1];
							count++;
						}
						//printf("count %d \n", count);	
						count--;			
						ReadyQ[count] = firstVal;
						//printf("end %d \n", ReadyQ[count]);
						
						toWait = 0;
					}
					
					/*
					count = 0;
					printf("New total %d \n", newTotal);	
					while(count < buffSize){
						printf("Buffer %d\n", Buffer[count]);
						count++;
					}
					count = 0;
					while(count < 5){
						printf("Wait %d\n", Wait[count]);					
						count++;
					}
					
					count = 0;
					while(count < newTotal){
						printf("END %d\n", ReadyQ[count]); 
						count++;
					} */
				}	
			//}
			}
			//iteration++;
			
		}
		printf("\n");
	}
}

void addToBuffer(int val){
	


}

void addToWait(int val){



}

void init_Buffer(int BuffSize){
	int count = 0;
	while(count < BuffSize){
		Buffer[count] = 0;
		count++;
	}


}

void rotateReadyQ(int size){
	int temp = 0;
	temp = ReadyQ[0];
	printf("%d", temp);
	for(int i = 0; i < size; i++){
		ReadyQ[i] = ReadyQ[i + 1];
		printf("%d\n", ReadyQ[i]);
	
	}
	
	ReadyQ[size - 1] = temp;
	
	

}


void Run(int size, int buffSize, int *ptr){
	init_Buffer(size);
	//rotateReadyQ(size);	
	//int temp = 0;
	//int count = 0;
	//int RQOne = ReadyQ[0];
	//printf("%d\n", ReadyQ[0]);
	//printf("%d\n", ReadyQ[1]);
	
	int count = 0;
	while(count < size){
		printf("%d\n", *(ReadyQ + count)); 
		count++;
	}



	if(buff_full == 1){
		//Add RQ[0] to buff
		
	} else {
		//Add RQ[0] to wait[len - 1]
		
	}
	


}



int main(){
	struct Queue RunQ;
	
	read_lines();

}
